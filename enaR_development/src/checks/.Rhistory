Tbal.in
round(bal(as.extended(em.net),method='output'),3) - Tbal.out
Tbal.out
as.extended(balance(em.net,method='IO'))
Tbal.io
Tbal.oi
as.extended(balance(em.net,method='OI'))
Tbal.oi
as.extended(balance(em.net,method='OI'))
as.extended(balance(em.net,method='OI')) - Tbal.oi
checks[[26]]
checks[[26]]
checks[[27]]
checks[[28]]
checks[[30]]
checks[[30]]
checks[[30]]
checks
Tbal.in <- matrix(c(0,26.506,0,0,104.383,
rm(list=ls())
args <- commandArgs(trailingOnly = TRUE)
balance <-
  function(x,method=c('AVG2','AVG','IO','OI','I','O'),tol=5){
                                        #Check for network class
  if (class(x) != 'network'){warning('x is not a network class object')}
  T <- as.extended(x) #convert to extended format
  n <- nrow(x%n%'flow')
                                        #checks
  check <- ssCheck(x,tol)
  if (check){
    print('BALANCED',quote=FALSE);
    x%n%'balanced' = TRUE;
    return(x);
    stop
  }else{
    method <- method[1]
    print(method,quote= FALSE)
                                        #balancing
    if (method == 'AVG'){  ##Using the AVG method
      T.bal = 0.5 * (bal(T,'input') + bal(T,'output'))
    }else if (method == 'AVG2'){   ##Using the AVG2 method
      T.bal <- 0.5 *  (bal((0.5 * bal(T,'output') + 0.5 * T),'input')
                       + bal((0.5 * bal(T,'input') + 0.5 * T),'output'))
    }else if (method == 'IO'){   ##Using the IO method
      T.bal <- bal((0.5 * bal(T,'input') + 0.5 * T),'output')
    }else if (method == 'OI'){   ##Using the OI method
      T.bal <- bal((0.5 * bal(T,'output') + 0.5 * T),'input')
    }else if (method == 'I'){  # using the Input method
      T.bal <- bal(T,'input')
    }else if (method == 'O'){
      T.bal <- bal(T,'output')
    }else {warning('Unknown balancing method')}
                                        #convert balanced model into network class
    x%n%'flow' <- T.bal[1:n,1:n]
    x%v%'input' <- T.bal[(n+3),1:n]
    x%v%'export' <- T.bal[1:n,(n+1)]
    x%v%'respiration' <- T.bal[1:n,(n+2)]
    x%v%'output' <- (x%v%'export' + x%v%'respiration')
    x%v%'storage' <- x%v%'storage'
                                        #check for balancing and return output
    if (ssCheck(x)){
      x%n%'balanced' <- TRUE
      return(x)
    }else{
                                        #return false for unbalanced models
      warning('Model was not balanced.')}
      x%n%'balanced' <- FALSE
      return(x)
  }

}
q()
y
citation('enaR')
check.out
checks
names(checks)
S
SP
P
Q
PP
QP
CN
CQ
CQ
D
DS
DS
U
Y
US
YS
names(enaStorage(oyster))
enaStorage(oyster)$X
enaStorage
x
dt
names(enaStructure(fb.oyster))
enaUtility(fb.oyster)
names(enaUtility(fb.oyster))
enaUtility
names(enaUtility(fb.oyster),type='storage')
names(enaUtility(fb.oyster),type='storage')
names(enaUtility(fb.oyster,type='storage'))
names(enaUtility(fb.oyster))
test
test
get.ns(fb.oyster)
all.ns <- get.ns(fb.oyster)
names(all.ns)
names(test)
test
rm(list=ls())
citation('enaR')
all.ns
data(bgcModels)
names(bgcModels)
bgcModels[[42]]
balance(bgcModels[[42]])
enaStorage(bgcModels[[42]])
enaStorage(balance(bgcModels[[42]]))
all.ns
data
data(bgcModels)
test <- enaStorage(balance(bgcModels[[42]]))
test$ns
names(all.ns)
names(all.ns)
names(all.ns)
names(ep)
ep.ns
length(ep.ns)
length(ns.all)
length(all.ns)
all.ns
ep.ns
cbind(all.ns,ep.ns)
cbind(all.ns,ep.ns)
all.ns
ep.ns
length(ep.ns)
length(all.ns)
mode(ep.ns)
mode(all.ns)
as.numeric(all.ns)
cbind(as.numeric(all.ns),ep.ns)
test <- round(cbind(as.numeric(all.ns),ep.ns),5)
test
ep.ns
